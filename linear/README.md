# Linear

線形型を試す

## 線形型に関連する機能

### プリミティブ

- `__linear<'T>`
    - ビルトインの線形型。`'T` 型の値をラップしたもの
- `__acquire<'T>` : `'T -> __linear<'T>`
    - 任意の値をラップして `__linear` 型を作る
    - unsafe操作
- `__dispose<'T>` : `__linear<'T> -> 'T`
    - `__linear` 型の値を破棄して中身を取り出す
    - unsafe操作

### 線形型

レコード型などを宣言する際にそれに線形型であるとマークするのではなく、`__linear` 型を所有するような型は自動的に線形型であるとみなす、という方針にする

`__linear<'T>` 型自体は線形型であり、それを内部に含むようなタプルも線形型である

### 線形検査

型検査の後、線形型の変数がそれぞれ、ちょうど1回使われることを検査する。以下の手順で検査する

- 式を型検査する際に、その式のスコープに含まれる線形型のローカル変数のそれぞれについて、使用済みか否かのマップを持つ
- **変数の導入**:
    関数のパラメータや変数パターンに訪問する際に、それが線形型なら、それをマップに未使用の変数として登録する
- **変数の除去**:
    スコープを抜ける際に、そのスコープで導入されたすべての変数がマップに使用済みとして登録されていることを確かめる (そうでなければ値がリークしてしまう)。マップからそれらの変数を取り除く
- **変数の使用**:
    変数式を検査するとき、マップにその変数が未使用として登録されていることを確かめる (そうでなければ破棄済みの値を使ってしまう)。その変数を使用済みとしてマークする
- **分岐**:
    if式を検査するとき、then節の検査とelse節の検査には同じマップを使う。それぞれの節の検査後のマップの状態を検証して、if式の外部で定義された変数のうち、それぞれの節の内部で使用済みにマークされる変数の集合は一致することを確かめる (片方では使用されるが他方では使用されないような変数があれば、その値がリークしてしまう)
- **ワイルドカード**:
    ワイルドカードパターンは、それが線形型を持たないことを確かめる (そうでなければ値がリークする)

実装は TypeCheck.fs を参照

### 余談: その他の言語機能

このプロジェクトでは試していないが、線形検査に影響がある典型的な言語機能として以下のようなものがある

- レコード: レコードのフィールドが線形型のとき、線形使用を検査するマップは変数だけでなくレコードのフィールドも未使用か使用済みかをマークする必要がある
- クロージャ: 関数がオブジェクトとして構築されるとき、その関数がキャプチャしている変数はオブジェクトのフィールドとしてコピーされるので、それの型が線形型なら、使用済みとしてマークする必要がある
- 多相: 多相関数に線形型の値を渡すと上記の検査では線形使用を保証できない (例えば `(fun x -> x, x) (__acquire 0)`)。関数型や型変数に線形性のための制約をかける必要がある ([System-Fo](https://github.com/kpavery/System-Fo) などを参照)

## 抽象構文

```
    型 T :=
        int
        | unit
        | ( T )         カッコ
        | T * T         ペア
        | T -> T        関数型
        | __linear<T>   線形コンテナ

    パターン P :=
        ident           変数
        | _             ワイルドカード
        | ( P )         カッコ
        | P, P          ペア
        | ident P       ラップ (バリアント)

    式 E :=
        number          数値リテラル
        | ( E )         カッコ式
        | E ; E         順次
        | E E           関数適用
        | E, E          ペア
        | E + E         加算
        | E = E         等価性の比較
        | let P = E     束縛
        | if E then E   分岐
               else E
          end
        | assert E      表明
        | __acquire E   線形獲得
        | __dispose E   線形破棄

    宣言 D :=
        let ident params* : T = E   関数宣言
        | expect string { E }       成功テスト
        | expect_error string { E } 失敗テスト
```

### 関数宣言

関数宣言の構文は F# と同様。ただし型注釈は必須

`let ident param1 param2 ... : result = E`

本体が1行のとき

```fs
let f1 (x: int) (y: int) : int = x + y
```

本体が複数行のとき

```fs
let f2 (x: int) (y: int) : int = (
    let xx = x * x
    let yy = y * y
    xx + yy
)
```

### expect宣言

`expect "タイトル" ( 本体 )`

本体の式の評価が正常に完了することを表す

### expect_error宣言

`expect_error "タイトル" ( 本体 )`

本体の式の型検査が通らないことを表す

----

## 余談: 具象構文

具象構文は F# をベースにしつつ、レイアウトルールを排除したかたちになっている

### 自動セミコロン挿入

字句解析の後、行末が特定の種類のトークンである行の末尾に ';' を挿入する。対象となるトークンの種類は式の末尾になりうるもの:

- 数値、識別子、`end`, `)`

(Go言語と同様の仕組み)

### 節

一部の式は節 (clause) という構文になっている。これは式を `;` 区切りにしたもので、前後の冗長な `;` も無視される

`()` の内部、if式のthen節・else節の部分は節になっている

### let式とブロック

伝統的なML系の言語と異なり、`let` は `in` 節を持たない。代わりに、ブロック (カッコ式) の内部にlet式を配置し、後続の式で変数を使う

`let` 自体は `()` に評価される。`let` はブロックの内部にだけ出現できる

ブロックを評価した値は、節が空なら `()` (ユニット)、空でなければ最後の式を評価した値に等しい

(Rustのlet文と同様の仕組み。ただしRustと違って、最後の式の後に `;` がついていても、その式の値がブロックの値になる)
