#[macro_use]
extern crate serde_derive;

use std::fs;
use std::io::Write;
use std::path::PathBuf;

#[derive(Deserialize)]
struct TestCaseIo {
    stdin: Option<String>,
    stdout: Option<String>,
}

#[derive(Deserialize)]
struct TestCaseEval {
    name: Option<String>,
    src: String,
    stdin: Option<String>,
    stdout: Option<String>,
}

#[derive(Deserialize)]
struct TestCaseError {
    name: Option<String>,
    src: String,
    err: String,
}

/// Test case can contain multiple eval cases:
///
/// > [[eval]]
/// > name = ""   # defaults to the index
/// > src = ""
/// > stdin = ""  # defaults to ""
/// > stdout = "" # defaults to ""
///
/// and multiple error cases.
///
/// > [[error]]
/// > name = ""   # defaults to the index
/// > src = ""
/// > err = ""    # The expected error.
///
/// If you want to feed a number of combination of
/// stdin/stdout pairs to single code, you can write this.
///
/// > src = ""
/// >
/// > [[io]]
/// > stdin = ""  # defaults to ""
/// > stdout = "" # defaults to ""
#[derive(Deserialize)]
struct TestCase {
    src: Option<String>,
    io: Option<Vec<TestCaseIo>>,
    eval: Option<Vec<TestCaseEval>>,
    error: Option<Vec<TestCaseError>>,
}

#[derive(Deserialize)]
enum CompiledTestCase {
    Eval {
        name: String,
        src: String,
        ios: Vec<(String, String)>,
    },
    Err {
        name: String,
        src: String,
        err: String,
    },
}

const TEMPLATE: &str = r##"//! Generated by `test_gen`.

#![cfg(test)]

use picomet_lang_compiler::tests::{eval_tests, test_err, test_snapshot};
${TESTS}"##;

fn normalize_eol(text: &str) -> String {
    text.replace("\r\n", "\n")
}

fn parse_toml_files() -> Vec<CompiledTestCase> {
    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let tests_dir = root_dir.join("../tests");

    let mut cases = vec![];

    for toml_path in fs::read_dir(&tests_dir).unwrap() {
        let toml_path = toml_path.as_ref().unwrap().path();
        if toml_path
            .extension()
            .and_then(|ext| ext.to_str())
            .unwrap_or("")
            != "toml"
        {
            continue;
        }
        let name = toml_path.file_stem().unwrap().to_str().unwrap().to_string();

        let contents = fs::read(&toml_path).unwrap();
        let case: TestCase = toml::from_slice(&contents)
            .unwrap_or_else(|err| panic!("Error {:?} in {:?}", err, toml_path));
        let io_count = case.io.as_ref().map(|io| io.len()).unwrap_or(0);

        // Top-level eval tests.
        match (case.src, io_count, case.io) {
            (Some(src), 0, _) => {
                cases.push(CompiledTestCase::Eval {
                    name: name.clone(),
                    src,
                    ios: vec![("".to_string(), "".to_string())],
                });
            }
            (Some(src), _, Some(io)) => {
                let io = io
                    .into_iter()
                    .map(|io| {
                        (
                            io.stdin.unwrap_or(String::new()),
                            io.stdout.unwrap_or(String::new()),
                        )
                    })
                    .collect::<Vec<_>>();
                cases.push(CompiledTestCase::Eval {
                    name: name.clone(),
                    src,
                    ios: io,
                });
            }
            _ => {}
        }

        // Eval tests.
        for (i, eval) in case.eval.into_iter().flat_map(|cases| cases).enumerate() {
            cases.push(CompiledTestCase::Eval {
                name: format!("{}_{}", name, eval.name.unwrap_or_else(|| format!("{}", i))),
                src: eval.src,
                ios: vec![(
                    eval.stdin.unwrap_or(String::new()),
                    eval.stdout.unwrap_or(String::new()),
                )],
            });
        }

        // Error tests.
        for (i, error) in case.error.into_iter().flat_map(|cases| cases).enumerate() {
            cases.push(CompiledTestCase::Err {
                name: format!(
                    "{}_{}",
                    name,
                    error.name.unwrap_or_else(|| format!("{}", i))
                ),
                src: error.src,
                err: error.err,
            });
        }
    }

    cases
}

fn file_name_to_fn_name(name: &str) -> String {
    name.replace("-", "_")
}

fn generate_test_fn(case: &CompiledTestCase, out: &mut Vec<u8>) {
    match case {
        CompiledTestCase::Eval { name, src, ios } => {
            let fn_name = file_name_to_fn_name(&name);
            let ios = ios
                .iter()
                .map(|(stdin, stdout)| {
                    format!(
                        r####"{ttt}({lf}{tttt}r##"{stdin}"##,{lf}{tttt}r##"{stdout}"##,{lf}{ttt}),"####,
                        stdin = stdin,
                        stdout = stdout,
                        lf = "\n",
                        ttt = "            ",
                        tttt = "                ",
                    )
                })
                .collect::<Vec<_>>()
                .join("\n");

            write!(
                out,
                r####"
#[test]
fn {name}() {{
    eval_tests(
        r##"{src}"##,
        &[
{ios}
        ]
    )
}}
"####,
                name = fn_name,
                src = src,
                ios = ios,
            )
            .unwrap();
        }
        CompiledTestCase::Err { name, src, err } => {
            let fn_name = file_name_to_fn_name(&name);
            write!(
                out,
                r####"
#[test]
fn {name}() {{
    test_err(
        r##"{src}"##,
        r##"{err}"##,
    );
}}
"####,
                name = fn_name,
                src = src,
                err = err,
            )
            .unwrap();
        }
    }
}

fn generate_snapshot_test_fn(case: &CompiledTestCase, out: &mut Vec<u8>) {
    match case {
        CompiledTestCase::Eval { name, src, .. } => {
            let fn_name = file_name_to_fn_name(&name);
            write!(
                out,
                r####"
#[test]
fn snapshot_{name}() {{
    test_snapshot("{name}", r##"{src}"##)
}}
"####,
                name = fn_name,
                src = src
            )
            .unwrap();
        }
        CompiledTestCase::Err { .. } => {}
    }
}

fn generate_test_file(cases: Vec<CompiledTestCase>) -> String {
    let mut out = vec![];
    for case in cases {
        generate_test_fn(&case, &mut out);
        generate_snapshot_test_fn(&case, &mut out);
    }
    let out = String::from_utf8(out).unwrap();

    TEMPLATE.replace("${TESTS}", &out)
}

fn write_to_test_file(content: String) {
    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let target_file = root_dir.join("../compiler/tests/tests_generated.rs");

    let old_content = fs::read_to_string(&target_file).unwrap_or_else(|_| "".to_string());
    if content == old_content {
        return;
    }

    fs::write(&target_file, &content).unwrap();
}

pub fn main() {
    let cases = parse_toml_files();
    write_to_test_file(normalize_eol(&generate_test_file(cases)));
}
