fix fn assert_eq(in actual: int, in expected: int) -> () {
  let mut assert_eq_res: () = extern_assert_eq(
    in actual
    in expected
  )
  jump return(move assert_eq_res)
}

fix fn inc(ref x: int) -> () {
  let mut n: int = 1
  let mut prim_add_res: int = prim_add(
    move x
    move n
  )
  let mut prim_assign_res: () = prim_assign(
    ref x
    move prim_add_res
  )
  jump return(move prim_assign_res)
}

fix fn main() -> () {
  let mut n_2: int = 1
  fix label let_next(mut a: infer) -> never {
    let mut n_3: int = 1
    let mut assert_eq_res_2: infer = assert_eq(
      in a
      in n_3
    )
    let mut inc_res: infer = inc(ref a)
    let mut n_4: int = 2
    let mut assert_eq_res_3: infer = assert_eq(
      in a
      in n_4
    )
    let mut inc_res_2: infer = inc(ref a)
    let mut n_5: int = 3
    let mut assert_eq_res_4: infer = assert_eq(
      in a
      in n_5
    )
    jump return(move assert_eq_res_4)
  }

  jump let_next(in n_2)
}

__noop
