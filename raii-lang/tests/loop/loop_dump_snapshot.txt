fix fn assert_eq(in actual, in expected) {
  let assert_eq_res = extern_assert_eq(
    in actual
    in expected
  )
  jump return(move assert_eq_res)
}

fix fn print(in s) {
  let print_res = extern_print(in s)
  jump return(move print_res)
}

fix fn main() {
  let print_res_2 = print(in "before loop")
  fix label a_next(mut a) {
    fix label do_break() {
      let print_res_3 = print(in "after loop")
      jump return(move print_res_3)
    }

    fix label do_continue() {
      let assert_eq_res_2 = assert_eq(
        in a
        in a
      )
      let prim_eq_res = prim_eq(
        in a
        in 5
      )
      fix label if_next(mut res) {
        let prim_eq_res_2 = prim_eq(
          in a
          in 2
        )
        fix label if_next_2(mut res_2) {
          let prim_add_res = prim_add(
            move a
            move 1
          )
          let prim_assign_res = prim_assign(
            ref a
            move prim_add_res
          )
          jump do_continue()
        }

        if prim_eq_res_2 {
          let prim_add_res_2 = prim_add(
            move a
            move 2
          )
          let prim_assign_res_2 = prim_assign(
            ref a
            move prim_add_res_2
          )
          jump do_continue()
        } else {
          jump if_next_2(move 0)
        }
      }

      if prim_eq_res {
        jump do_break()
      } else {
        jump if_next(move 0)
      }
    }

    jump do_continue()
  }

  jump a_next(in 0)
}

0
