fix fn assert_eq(in actual: int, in expected: int) -> () {
  let mut assert_eq_res: () = extern_assert_eq(
    in actual
    in expected
  )
  jump return(move assert_eq_res)
}

fix fn print(in s: string) -> () {
  let mut print_res: () = extern_print(in s)
  jump return(move print_res)
}

fix fn main() -> () {
  let mut s_2: string = "before loop"
  let mut print_res_2: () = print(in s_2)
  let mut n: int = 0
  fix label let_next(mut a: int) -> never {
    fix label do_break() -> never {
      let mut s_3: string = "after loop"
      let mut print_res_3: () = print(in s_3)
      jump return(move print_res_3)
    }

    fix label do_continue() -> never {
      let mut assert_eq_res_2: () = assert_eq(
        in a
        in a
      )
      let mut n_2: int = 5
      let mut prim_eq_res: bool = prim_eq(
        in a
        in n_2
      )
      fix label if_next(mut res: int) -> never {
        let mut n_3: int = 2
        let mut prim_eq_res_2: bool = prim_eq(
          in a
          in n_3
        )
        fix label if_next_2(mut res_2: int) -> never {
          let mut n_4: int = 1
          let mut prim_add_res: int = prim_add(
            move a
            move n_4
          )
          let mut prim_assign_res: () = prim_assign(
            ref a
            move prim_add_res
          )
          jump do_continue()
        }

        if prim_eq_res_2 {
          let mut n_5: int = 2
          let mut prim_add_res_2: int = prim_add(
            move a
            move n_5
          )
          let mut prim_assign_res_2: () = prim_assign(
            ref a
            move prim_add_res_2
          )
          jump do_continue()
        } else {
          jump if_next_2(move __noop)
        }
      }

      if prim_eq_res {
        jump do_break()
      } else {
        jump if_next(move __noop)
      }
    }

    jump do_continue()
  }

  jump let_next(in n)
}

__noop
