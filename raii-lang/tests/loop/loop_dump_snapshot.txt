fix fn assert_eq(in actual: int, in expected: int) -> () {
  let assert_eq_res = extern_assert_eq(
    in actual
    in expected
  )
  jump return(move assert_eq_res)
}

fix fn print(in s: string) -> () {
  let print_res = extern_print(in s)
  jump return(move print_res)
}

fix fn main() -> () {
  let s_2 = "before loop"
  let print_res_2 = print(in s_2)
  let n = 0
  fix label let_next(mut a: infer) -> never {
    fix label do_break() -> never {
      let s_3 = "after loop"
      let print_res_3 = print(in s_3)
      jump return(move print_res_3)
    }

    fix label do_continue() -> never {
      let assert_eq_res_2 = assert_eq(
        in a
        in a
      )
      let n_2 = 5
      let prim_eq_res = prim_eq(
        in a
        in n_2
      )
      fix label if_next(mut res: int) -> never {
        let n_3 = 2
        let prim_eq_res_2 = prim_eq(
          in a
          in n_3
        )
        fix label if_next_2(mut res_2: int) -> never {
          let n_4 = 1
          let prim_add_res = prim_add(
            move a
            move n_4
          )
          let prim_assign_res = prim_assign(
            ref a
            move prim_add_res
          )
          jump do_continue()
        }

        if prim_eq_res_2 {
          let n_5 = 2
          let prim_add_res_2 = prim_add(
            move a
            move n_5
          )
          let prim_assign_res_2 = prim_assign(
            ref a
            move prim_add_res_2
          )
          jump do_continue()
        } else {
          jump if_next_2(move __noop)
        }
      }

      if prim_eq_res {
        jump do_break()
      } else {
        jump if_next(move __noop)
      }
    }

    jump do_continue()
  }

  jump let_next(in n)
}

__noop
