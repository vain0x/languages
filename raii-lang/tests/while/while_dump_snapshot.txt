fix fn assert_eq(in actual: int, in expected: int) -> () {
  let mut assert_eq_res: () = extern_assert_eq(
    in actual
    in expected
  )
  jump return(move assert_eq_res)
}

fix fn main() -> () {
  let mut b: bool = true
  fix label let_next(mut ok: infer) -> never {
    let mut n: int = 0
    fix label let_next_2(mut a: infer) -> never {
      fix label do_break() -> never {
        let mut n_2: int = 5
        let mut assert_eq_res_2: infer = assert_eq(
          in a
          in n_2
        )
        jump return(move assert_eq_res_2)
      }

      fix label do_continue() -> never {
        if ok {
          let mut assert_eq_res_3: infer = assert_eq(
            in a
            in a
          )
          let mut n_3: int = 1
          let mut prim_add_res: int = prim_add(
            move a
            move n_3
          )
          let mut prim_assign_res: () = prim_assign(
            ref a
            move prim_add_res
          )
          let mut n_4: int = 5
          let mut prim_eq_res: bool = prim_eq(
            in a
            in n_4
          )
          fix label if_next(mut res: int) -> never {
            jump do_continue()
          }

          if prim_eq_res {
            let mut b_2: bool = false
            let mut prim_assign_res_2: () = prim_assign(
              ref ok
              move b_2
            )
            jump if_next(move prim_assign_res_2)
          } else {
            jump if_next(move __noop)
          }
        } else {
          jump do_break()
        }
      }

      jump do_continue()
    }

    jump let_next_2(in n)
  }

  jump let_next(in b)
}

__noop
