fix fn assert_eq(in actual: int, in expected: int) -> () {
  let assert_eq_res = extern_assert_eq(
    in actual
    in expected
  )
  jump return(move assert_eq_res)
}

fix fn main() -> int {
  fix label ok_next(mut ok: int) -> never {
    fix label a_next(mut a: int) -> never {
      fix label do_break() -> never {
        let assert_eq_res_2 = assert_eq(
          in a
          in 5
        )
        jump return(move assert_eq_res_2)
      }

      fix label do_continue() -> never {
        if ok {
          let assert_eq_res_3 = assert_eq(
            in a
            in a
          )
          let prim_add_res = prim_add(
            move a
            move 1
          )
          let prim_assign_res = prim_assign(
            ref a
            move prim_add_res
          )
          let prim_eq_res = prim_eq(
            in a
            in 5
          )
          fix label if_next(mut res: int) -> never {
            jump do_continue()
          }

          if prim_eq_res {
            let prim_assign_res_2 = prim_assign(
              ref ok
              move false
            )
            jump if_next(move prim_assign_res_2)
          } else {
            jump if_next(move 0)
          }
        } else {
          jump do_break()
        }
      }

      jump do_continue()
    }

    jump a_next(in 0)
  }

  jump ok_next(in true)
}

0
