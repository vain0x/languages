fix fn assert_eq(in actual: int, in expected: int) -> () {
  let assert_eq_res = extern_assert_eq(
    in actual
    in expected
  )
  jump return(move assert_eq_res)
}

fix fn main() -> () {
  let b = true
  fix label let_next(mut ok: infer) -> never {
    let n = 0
    fix label let_next_2(mut a: infer) -> never {
      fix label do_break() -> never {
        let n_2 = 5
        let assert_eq_res_2 = assert_eq(
          in a
          in n_2
        )
        jump return(move assert_eq_res_2)
      }

      fix label do_continue() -> never {
        if ok {
          let assert_eq_res_3 = assert_eq(
            in a
            in a
          )
          let n_3 = 1
          let prim_add_res = prim_add(
            move a
            move n_3
          )
          let prim_assign_res = prim_assign(
            ref a
            move prim_add_res
          )
          let n_4 = 5
          let prim_eq_res = prim_eq(
            in a
            in n_4
          )
          fix label if_next(mut res: int) -> never {
            jump do_continue()
          }

          if prim_eq_res {
            let b_2 = false
            let prim_assign_res_2 = prim_assign(
              ref ok
              move b_2
            )
            jump if_next(move prim_assign_res_2)
          } else {
            jump if_next(move __noop)
          }
        } else {
          jump do_break()
        }
      }

      jump do_continue()
    }

    jump let_next_2(in n)
  }

  jump let_next(in b)
}

__noop
